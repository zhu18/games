<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åˆæˆå¤§è¥¿ç“œ - ä¼‘é—²å°æ¸¸æˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        // Tailwindé…ç½®
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#FF6B6B',
                        secondary: '#4ECDC4',
                        accent: '#FFD166',
                        dark: '#292F36',
                        light: '#F7FFF7'
                    },
                    fontFamily: {
                        game: ['"Comic Sans MS"', '"Marker Felt"', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .game-shadow {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            }
            .fruit-shadow {
                filter: drop-shadow(0 4px 3px rgba(0, 0, 0, 0.1));
            }
            .pulse-animation {
                animation: pulse 0.3s ease-in-out;
            }
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            .slide-up {
                animation: slideUp 0.5s ease-out forwards;
            }
            @keyframes slideUp {
                from { transform: translateY(100px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
            .bounce-in {
                animation: bounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            }
            @keyframes bounceIn {
                0% { transform: scale(0.3); opacity: 0; }
                50% { transform: scale(1.05); }
                70% { transform: scale(0.9); }
                100% { transform: scale(1); opacity: 1; }
            }
            .tap-indicator {
                position: absolute;
                border: 2px solid rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                transform: translate(-50%, -50%);
                pointer-events: none;
                animation: tapEffect 0.6s ease-out forwards;
            }
            @keyframes tapEffect {
                0% { width: 0; height: 0; opacity: 1; }
                100% { width: 40px; height: 40px; opacity: 0; }
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-light to-blue-50 min-h-screen font-game text-dark overflow-x-hidden">
    <!-- æ¸¸æˆå®¹å™¨ -->
    <div class="container mx-auto px-4 py-6 max-w-md">
        <!-- æ¸¸æˆæ ‡é¢˜ -->
        <div class="text-center mb-4 slide-up">
            <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-primary mb-2">
                <i class="fa fa-watermelon mr-2"></i>åˆæˆå¤§è¥¿ç“œ
            </h1>
            <p class="text-gray-600">ç‚¹å‡»å±å¹•æ”¾ç½®æ°´æœï¼Œç›¸åŒæ°´æœç¢°æ’åˆæˆæ›´å¤§çš„</p>
        </div>

        <!-- åˆ†æ•°é¢æ¿ -->
        <div class="flex justify-between items-center mb-4 px-4 py-2 bg-white rounded-lg game-shadow slide-up" style="animation-delay: 0.1s">
            <div class="flex items-center">
                <i class="fa fa-star text-accent text-xl mr-2"></i>
                <span class="font-bold">åˆ†æ•°:</span>
                <span id="score" class="ml-2 text-xl font-bold text-primary">0</span>
            </div>
            <div class="flex items-center">
                <i class="fa fa-trophy text-accent text-xl mr-2"></i>
                <span class="font-bold">æœ€é«˜:</span>
                <span id="highScore" class="ml-2 text-xl font-bold text-primary">0</span>
            </div>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div id="gameContainer" class="relative w-full bg-white rounded-xl overflow-hidden game-shadow aspect-[3/4] mb-4 slide-up" style="animation-delay: 0.2s">
            <!-- æ¸¸æˆç»“æŸé®ç½© -->
            <div id="gameOver" class="absolute inset-0 bg-dark bg-opacity-70 flex flex-col items-center justify-center z-50 hidden">
                <h2 class="text-[clamp(1.5rem,4vw,2.5rem)] font-bold text-white mb-2 bounce-in">æ¸¸æˆç»“æŸ!</h2>
                <p class="text-white text-lg mb-4">æœ€ç»ˆå¾—åˆ†: <span id="finalScore" class="text-accent font-bold">0</span></p>
                <button id="restartBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-3 px-8 rounded-full transition-all transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-2 focus:ring-primary/50">
                    å†æ¥ä¸€å±€ <i class="fa fa-refresh ml-1"></i>
                </button>
            </div>
            
            <!-- ä¸‹ä¸€ä¸ªæ°´æœé¢„è§ˆ -->
            <div id="nextFruitPreview" class="absolute top-4 right-4 bg-white bg-opacity-80 p-2 rounded-full game-shadow z-10">
                <canvas id="nextFruitCanvas" width="60" height="60" class="rounded-full"></canvas>
            </div>
            
            <!-- æ°´æœå°†åœ¨è¿™é‡Œç”Ÿæˆ -->
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
        </div>

        <!-- æ“ä½œè¯´æ˜
        <div id="help" class="bg-white rounded-lg p-4 game-shadow " style="animation-delay: 0.4s">
            <h3 class="font-bold text-lg mb-2 text-primary"><i class="fa fa-info-circle mr-1"></i> æ¸¸æˆè¯´æ˜</h3>
            <ul class="text-gray-700 space-y-1 text-sm">
                <li><i class="fa fa-check-circle text-secondary mr-1"></i> ç‚¹å‡»å±å¹•ä»»æ„ä½ç½®æ”¾ç½®æ°´æœ</li>
                <li><i class="fa fa-check-circle text-secondary mr-1"></i> ç›¸åŒæ°´æœç¢°æ’å¯åˆæˆæ›´å¤§çš„æ°´æœ</li>
                <li><i class="fa fa-check-circle text-secondary mr-1"></i> æœ€ç»ˆç›®æ ‡æ˜¯åˆæˆå¤§è¥¿ç“œ</li>
                <li><i class="fa fa-check-circle text-secondary mr-1"></i> å³ä¸Šè§’æ˜¾ç¤ºä¸‹ä¸€ä¸ªè¦å‡ºç°çš„æ°´æœ</li>
                <li><i class="fa fa-check-circle text-secondary mr-1"></i> æ°´æœå †æ»¡å±å¹•åˆ™æ¸¸æˆç»“æŸ</li>
            </ul>
        </div> -->
 <!-- éŸ³æ•ˆï¼šåˆå¹¶æ—¶æ’­æ”¾ -->
  <audio id="mergeSound" preload="auto">
    <source src="./sound/m.mp3" type="audio/mpeg">
  </audio>
          <!-- åº•éƒ¨ä½œè€…ä¿¡æ¯ -->
        <div style="
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        color: #978e85;
        text-align: center;
        z-index: 1000;
        ">
        Powered by zhu18@vip.qq.com
        </div>
    </div>

    <script>
        // æ’­æ”¾åˆæˆå£°éŸ³
        const mergeSound = document.getElementById('mergeSound');
        function playMergeSound() {
            mergeSound.currentTime = 0.1;
            mergeSound.play().catch(() => {}); // å¿½ç•¥è‡ªåŠ¨æ’­æ”¾é™åˆ¶é”™è¯¯
         }
        // ç­‰å¾…DOMåŠ è½½å®Œæˆ
        document.addEventListener('DOMContentLoaded', () => {
            // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const nextFruitCanvas = document.getElementById('nextFruitCanvas');
            const nextFruitCtx = nextFruitCanvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            function resizeCanvas() {
                const container = document.getElementById('gameContainer');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
            
            // åˆå§‹åŒ–æ—¶è°ƒæ•´å°ºå¯¸ï¼Œå¹¶ç›‘å¬çª—å£å¤§å°å˜åŒ–
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // ç‰©ç†å¼•æ“é…ç½® - è°ƒæ•´æ—‹è½¬ç›¸å…³å‚æ•°
            const physics = {
                gravity: 0.8,          // é‡åŠ›åŠ é€Ÿåº¦
                bounceCoefficient: 0.7,// å¼¹æ€§ç³»æ•°
                friction: 0.99,        // æ‘©æ“¦ç³»æ•°
                airResistance: 0.995,  // ç©ºæ°”é˜»åŠ›
                rotationFriction: 0.94,// æ—‹è½¬æ‘©æ“¦ (é™ä½å€¼ä»¥å¢åŠ é˜»å°¼ï¼Œä½¿æ—‹è½¬æ›´å¿«åœæ­¢)
                collisionThreshold: 0.5// ç¢°æ’æ£€æµ‹é˜ˆå€¼
            };
            
            // æ¸¸æˆé…ç½®
            const config = {
                maxFruits: 50,         // æœ€å¤§æ°´æœæ•°é‡
                spawnInterval: 500,    // æ°´æœç”Ÿæˆé—´éš”(æ¯«ç§’)
                minFruitSpeed: 2,      // æœ€å°ä¸‹è½é€Ÿåº¦
                maxFruitSpeed: 5,      // æœ€å¤§ä¸‹è½é€Ÿåº¦
                maxRotationSpeed: 0  // æœ€å¤§æ—‹è½¬é€Ÿåº¦ (é™ä½æ­¤å€¼ä½¿æ—‹è½¬æ›´æ…¢)
            };
            
          // æ°´æœç±»å‹å®šä¹‰ (æ–°å¢ç»Ÿä¸€å°ºå¯¸çš„imageå­—æ®µï¼Œæ›¿æ¢çº¯è‰²åœ†å½¢)
            const fruitTypes = [
            { name: 'æ¨±æ¡ƒ', color: '#FF1744', image:'ğŸ’', radius: 15, score: 10, next: 1, imageSize: 24 },     
            { name: 'è“è“', color: '#3F51B5', image:'ğŸ«', radius: 20, score: 20, next: 2, imageSize: 28 },     
            { name: 'è‰è“', color: '#E91E63', image:'ğŸ“', radius: 25, score: 30, next: 3, imageSize: 32 },    
            { name: 'æŸ æª¬', color: '#FFEB3B', image:'ğŸ‹', radius: 30, score: 40, next: 4, imageSize: 36 },    
            { name: 'çŒ•çŒ´æ¡ƒ', color: '#4CAF50', image:'ğŸ¥', radius: 35, score: 50, next: 5, imageSize: 40 },   
            { name: 'æ©™å­', color: '#FF9800', image:'ğŸŠ', radius: 40, score: 60, next: 6, imageSize: 50 },    
            { name: 'è‹¹æœ', color: '#F44336', image:'ğŸ', radius: 45, score: 70, next: 7, imageSize: 56 },    
            { name: 'è è', color: '#FBB97A', image:'ğŸ', radius: 50, score: 80, next: 8, imageSize: 65 },  
            { name: 'æŸšå­', color: '#8BC34A', image:'ğŸˆ', radius: 55, score: 90, next: 9, imageSize: 70 },     
            { name: 'æ¤°å­', color: '#607D8B', image:'ğŸ¥¥', radius: 60, score: 100, next: 10, imageSize: 80 },   
            { name: 'è¥¿ç“œ', color: '#2E7D32', image:'ğŸ‰', radius: 70, score: 110, next: null, imageSize: 90 }  
            ];
            
            // æ¸¸æˆçŠ¶æ€
            let state = {
                fruits: [],
                activeFruit: null,     // å½“å‰å¯æ”¾ç½®çš„æ°´æœ
                nextFruit: null,       // ä¸‹ä¸€ä¸ªæ°´æœ
                score: 0,
                highScore: localStorage.getItem('watermelonHighScore') || 0,
                gameOver: false,
                lastSpawnTime: 0,
                animationId: null,
                lastTime: 0,
                isDragging: false      // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨æ°´æœ
            };
            
            // æ›´æ–°æœ€é«˜åˆ†æ˜¾ç¤º
            document.getElementById('highScore').textContent = state.highScore;
            
            // åˆ›å»ºæ°´æœ
           // åˆ›å»ºæ°´æœï¼ˆè¡¥å……ï¼šç¡®ä¿typeä¸­çš„imageç›¸å…³å­—æ®µæ­£å¸¸èµ‹å€¼ï¼‰
            function createFruit(typeIndex = null) {
                const type = typeIndex !== null 
                    ? fruitTypes[typeIndex] 
                    : fruitTypes[Math.floor(Math.random() * 5)]; 
                
                return {
                    type: type, // å®Œæ•´ä¼ é€’typeå¯¹è±¡ï¼ˆåŒ…å«imageã€imageSizeç­‰å­—æ®µï¼‰
                    typeIndex: typeIndex !== null ? typeIndex : fruitTypes.indexOf(type),
                    x: canvas.width / 2,
                    y: 50,
                    vx: 0,
                    vy: 0,
                    ax: 0,
                    ay: 0,
                    radius: type.radius,
                    color: type.color,
                    mass: type.radius,
                    rotation: 0,
                    angularVelocity: 0,
                    merged: false,
                    isNew: true,
                    scale: 0,
                    isFalling: false
                };
            }
            
            // åˆå§‹åŒ–æ°´æœ
            state.activeFruit = createFruit();
            state.nextFruit = createFruit();
            updateNextFruitPreview();
            
            // ç»˜åˆ¶æ°´æœ
           function drawFruit(fruit, context = ctx, scale = 1) {
                context.save();
                
                // æ–°æ°´æœçš„ç¼©æ”¾åŠ¨ç”» - ç¡®ä¿ç¼©æ”¾å€¼ä¸ä¸ºè´Ÿ
                const drawScale = Math.max(0, fruit.isNew ? fruit.scale : 1); // å…³é”®ä¿®å¤ï¼šä½¿ç”¨Math.maxç¡®ä¿å€¼ä¸ä¸ºè´Ÿ
                const finalScale = drawScale * scale;
                
                // å¹³ç§»åˆ°æ°´æœä¸­å¿ƒä½ç½®
                context.translate(fruit.x * scale, fruit.y * scale);
                
                // åº”ç”¨æ—‹è½¬
                context.rotate(fruit.rotation);
                
                // ç»˜åˆ¶æ°´æœèƒŒæ™¯åœ†ï¼ˆç¡®ä¿åŠå¾„ä¸ä¸ºè´Ÿï¼‰
                const radius = Math.max(0, fruit.radius * finalScale); // å…³é”®ä¿®å¤ï¼šç¡®ä¿åŠå¾„ä¸ä¸ºè´Ÿ
                context.beginPath();
                context.arc(0, 0, radius, 0, Math.PI * 2);
                context.fillStyle = `${fruit.color}80`;
                context.fill();
                
                // æ·»åŠ é˜´å½±
                context.shadowColor = 'rgba(0, 0, 0, 0.2)';
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                
                // ç»˜åˆ¶æ°´æœimage
                const imageSize = Math.max(0, fruit.type.imageSize * finalScale); // ç¡®ä¿imageå°ºå¯¸ä¸ä¸ºè´Ÿ
                context.font = `${imageSize}px Arial, sans-serif`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = '#000';
                context.fillText(fruit.type.image, 0, 0);
                
                // ç§»é™¤é˜´å½±
                context.shadowBlur = 0;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 0;
                
                // // ç»˜åˆ¶æ°´æœåç§°
                // if (radius > 10) { // åŠå¾„è¶³å¤Ÿå¤§æ—¶æ‰æ˜¾ç¤ºåç§°ï¼Œé¿å…å°æ°´æœæ–‡å­—é‡å 
                //     const textSize = Math.max(0, 12 * finalScale); // ç¡®ä¿æ–‡å­—å°ºå¯¸ä¸ä¸ºè´Ÿ
                //     context.font = `bold ${textSize}px "Comic Sans MS", sans-serif`;
                //     context.fillStyle = 'white';
                //     context.textAlign = 'center';
                //     context.textBaseline = 'bottom';
                //     context.fillText(fruit.type.name, 0, radius - 4);
                // }
                
                context.restore();
            }
            
            // æ›´æ–°ä¸‹ä¸€ä¸ªæ°´æœé¢„è§ˆ
            function updateNextFruitPreview() {
                nextFruitCtx.clearRect(0, 0, nextFruitCanvas.width, nextFruitCanvas.height);
                
                if (state.nextFruit) {
                    // åœ¨å°ç”»å¸ƒä¸­å¤®ç»˜åˆ¶ä¸‹ä¸€ä¸ªæ°´æœ
                    const tempFruit = {
                        ...state.nextFruit,
                        x: nextFruitCanvas.width / 2,
                        y: nextFruitCanvas.height / 2,
                        isNew: false,
                        scale: 1,
                        rotation: 0
                    };
                    drawFruit(tempFruit, nextFruitCtx, 0.8);
                }
            }
            
            // ç‰©ç†å¼•æ“ï¼šæ›´æ–°æ°´æœç‰©ç†çŠ¶æ€
            function updatePhysics(fruit, deltaTime) {
              if (!fruit.isFalling) return;
    
                // åº”ç”¨é‡åŠ›åŠ é€Ÿåº¦
                fruit.ay = physics.gravity;
                
                // æ›´æ–°é€Ÿåº¦
                const timeFactor = deltaTime / 16;
                fruit.vx += fruit.ax * timeFactor;
                fruit.vy += fruit.ay * timeFactor;
                
                // åº”ç”¨ç©ºæ°”é˜»åŠ›
                fruit.vx *= physics.airResistance;
                fruit.vy *= physics.airResistance;
                
                // é™åˆ¶é€Ÿåº¦ï¼Œé˜²æ­¢æ•°å€¼æº¢å‡º
                fruit.vx = Math.max(-10, Math.min(10, fruit.vx));
                fruit.vy = Math.max(-10, Math.min(10, fruit.vy));
                
                // æ›´æ–°æ—‹è½¬
                fruit.rotation += fruit.angularVelocity * timeFactor;
                fruit.angularVelocity *= physics.rotationFriction;
                
                if (Math.abs(fruit.angularVelocity) < 0.001) {
                    fruit.angularVelocity = 0;
                }
                
                // æ›´æ–°ä½ç½®å¹¶é™åˆ¶èŒƒå›´ï¼Œé˜²æ­¢æ°´æœå‡ºç•Œå¯¼è‡´å¼‚å¸¸
                fruit.x = Math.max(fruit.radius, Math.min(canvas.width - fruit.radius, fruit.x + fruit.vx * timeFactor));
                fruit.y = Math.max(fruit.radius, Math.min(canvas.height * 1.2, fruit.y + fruit.vy * timeFactor));
                
                // è¾¹ç•Œæ£€æµ‹ - å·¦å³
                if (fruit.x - fruit.radius < 0) {
                    fruit.x = fruit.radius;
                    fruit.vx = -fruit.vx * physics.bounceCoefficient;
                    // ç¢°æ’æ—¶æ·»åŠ æ—‹è½¬ (é™ä½æ—‹è½¬å¼ºåº¦)
                    fruit.angularVelocity += fruit.vx * 0.02;
                    // é™åˆ¶æœ€å¤§æ—‹è½¬é€Ÿåº¦
                    fruit.angularVelocity = Math.max(
                        -config.maxRotationSpeed, 
                        Math.min(config.maxRotationSpeed, fruit.angularVelocity)
                    );
                } else if (fruit.x + fruit.radius > canvas.width) {
                    fruit.x = canvas.width - fruit.radius;
                    fruit.vx = -fruit.vx * physics.bounceCoefficient;
                    // ç¢°æ’æ—¶æ·»åŠ æ—‹è½¬ (é™ä½æ—‹è½¬å¼ºåº¦)
                    fruit.angularVelocity += fruit.vx * 0.02;
                    // é™åˆ¶æœ€å¤§æ—‹è½¬é€Ÿåº¦
                    fruit.angularVelocity = Math.max(
                        -config.maxRotationSpeed, 
                        Math.min(config.maxRotationSpeed, fruit.angularVelocity)
                    );
                }
                
                // è¾¹ç•Œæ£€æµ‹ - åº•éƒ¨
                if (fruit.y + fruit.radius > canvas.height) {
                    fruit.y = canvas.height - fruit.radius;
                    fruit.vy = -fruit.vy * physics.bounceCoefficient;
                    // èƒ½é‡æŸå¤±åˆ°ä¸€å®šç¨‹åº¦ååœæ­¢åå¼¹
                    if (Math.abs(fruit.vy) < physics.collisionThreshold) {
                        fruit.vy = 0;
                        fruit.ay = 0;
                    }
                    // ç¢°æ’æ—¶æ·»åŠ æ—‹è½¬ (é™ä½æ—‹è½¬å¼ºåº¦)
                    fruit.angularVelocity += fruit.vy * 0.015;
                    // é™åˆ¶æœ€å¤§æ—‹è½¬é€Ÿåº¦
                    fruit.angularVelocity = Math.max(
                        -config.maxRotationSpeed, 
                        Math.min(config.maxRotationSpeed, fruit.angularVelocity)
                    );
                }
                
                // åº”ç”¨åœ°é¢æ‘©æ“¦åŠ› (å½“æ¥è¿‘åœ°é¢æ—¶)
                if (Math.abs(fruit.y + fruit.radius - canvas.height) < 10 && 
                    Math.abs(fruit.vy) < physics.collisionThreshold * 2) {
                    fruit.vx *= physics.friction;
                    if (Math.abs(fruit.vx) < 0.05) {
                        fruit.vx = 0;
                    }
                }
            }
            
            // æ£€æŸ¥ç¢°æ’
            function checkCollision(fruit1, fruit2) {
                if (fruit1.merged || fruit2.merged) return false;
                
                const dx = fruit1.x - fruit2.x;
                const dy = fruit1.y - fruit2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = fruit1.radius + fruit2.radius - 2;
                
                return distance < minDistance;
            }
            
            // å¤„ç†ç¢°æ’å“åº”
            function resolveCollision(fruit1, fruit2) {
                // è®¡ç®—ç¢°æ’æ³•çº¿
                const dx = fruit2.x - fruit1.x;
                const dy = fruit2.y - fruit1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // é˜²æ­¢é™¤é›¶é”™è¯¯
                if (distance === 0) {
                    // éšæœºæ–¹å‘åˆ†ç¦»
                    fruit1.x -= 1;
                    fruit2.x += 1;
                    return;
                }
                
                // å½’ä¸€åŒ–æ³•çº¿
                const nx = dx / distance;
                const ny = dy / distance;
                
                // è®¡ç®—åˆ‡çº¿
                const tx = -ny;
                const ty = nx;
                
                // è®¡ç®—é‡å å¹¶åˆ†ç¦»
                const overlap = (fruit1.radius + fruit2.radius) - distance;
                if (overlap > 0) {
                    // åŸºäºè´¨é‡çš„åˆ†ç¦»
                    const totalMass = fruit1.mass + fruit2.mass;
                    const ratio1 = fruit2.mass / totalMass;
                    const ratio2 = fruit1.mass / totalMass;
                    
                    fruit1.x -= nx * overlap * ratio1;
                    fruit1.y -= ny * overlap * ratio1;
                    fruit2.x += nx * overlap * ratio2;
                    fruit2.y += ny * overlap * ratio2;
                }
                
                // è®¡ç®—æ²¿æ³•çº¿æ–¹å‘çš„é€Ÿåº¦åˆ†é‡
                const v1n = fruit1.vx * nx + fruit1.vy * ny;
                const v1t = fruit1.vx * tx + fruit1.vy * ty;
                const v2n = fruit2.vx * nx + fruit2.vy * ny;
                const v2t = fruit2.vx * tx + fruit2.vy * ty;
                
                // è®¡ç®—ç¢°æ’åçš„æ³•çº¿é€Ÿåº¦ (ä¸€ç»´å¼¹æ€§ç¢°æ’å…¬å¼)
                const v1nAfter = (v1n * (fruit1.mass - fruit2.mass) + 2 * fruit2.mass * v2n) / (fruit1.mass + fruit2.mass);
                const v2nAfter = (v2n * (fruit2.mass - fruit1.mass) + 2 * fruit1.mass * v1n) / (fruit1.mass + fruit2.mass);
                
                // åº”ç”¨å¼¹æ€§ç³»æ•°
                const elasticity = physics.bounceCoefficient;
                fruit1.vx = (v1nAfter * elasticity * nx) + (v1t * tx);
                fruit1.vy = (v1nAfter * elasticity * ny) + (v1t * ty);
                fruit2.vx = (v2nAfter * elasticity * nx) + (v2t * tx);
                fruit2.vy = (v2nAfter * elasticity * ny) + (v2t * ty);
                
                // æ·»åŠ æ—‹è½¬æ•ˆæœ (é™ä½æ—‹è½¬å¼ºåº¦)
                fruit1.angularVelocity += (v2n - v1n) * 0.01;
                fruit2.angularVelocity += (v1n - v2n) * 0.01;
                
                // é™åˆ¶æœ€å¤§æ—‹è½¬é€Ÿåº¦
                fruit1.angularVelocity = Math.max(
                    -config.maxRotationSpeed, 
                    Math.min(config.maxRotationSpeed, fruit1.angularVelocity)
                );
                fruit2.angularVelocity = Math.max(
                    -config.maxRotationSpeed, 
                    Math.min(config.maxRotationSpeed, fruit2.angularVelocity)
                );
            }
            
            // å¤„ç†æ°´æœåˆå¹¶
            function handleMerge(fruit1, fruit2) {
                // å¦‚æœæ˜¯ç›¸åŒç±»å‹çš„æ°´æœï¼Œå¯ä»¥åˆå¹¶
                if (fruit1.typeIndex === fruit2.typeIndex && fruit1.type.next !== null) {
                    // æ ‡è®°ä¸ºå·²åˆå¹¶
                    fruit1.merged = true;
                    fruit2.merged = true;
                    
                    // è®¡ç®—åˆå¹¶åçš„ä½ç½®ï¼ˆä¸¤ä¸ªæ°´æœçš„ä¸­ç‚¹ï¼‰
                    const mergeX = (fruit1.x + fruit2.x) / 2;
                    const mergeY = (fruit1.y + fruit2.y) / 2;
                    
                    // åˆ›å»ºæ–°çš„æ›´é«˜çº§åˆ«çš„æ°´æœ
                    const newFruit = createFruit(fruit1.type.next);
                    newFruit.x = mergeX;
                    newFruit.y = mergeY;
                    newFruit.isFalling = true;
                    
                    // ç»§æ‰¿éƒ¨åˆ†é€Ÿåº¦
                    newFruit.vx = (fruit1.vx + fruit2.vx) / 4;
                    newFruit.vy = (fruit1.vy + fruit2.vy) / 4 - 2; // ç»™ä¸€ä¸ªå‘ä¸Šçš„åˆé€Ÿåº¦
                    // é™ä½æ—‹è½¬ç»§æ‰¿çš„é€Ÿåº¦
                    newFruit.angularVelocity = (fruit1.angularVelocity + fruit2.angularVelocity) / 8;
                    
                    // æ·»åŠ æ–°æ°´æœ
                    state.fruits.push(newFruit);
                    
                    // åˆå¹¶éŸ³æ•ˆ
                    playMergeSound();

                    // å¢åŠ åˆ†æ•°
                    addScore(newFruit.type.score);
                    
                    // æ’­æ”¾åˆå¹¶åŠ¨ç”»
                    createMergeEffect(mergeX, mergeY, newFruit.radius, newFruit.type.score);
                    
                    return true;
                }
                return false;
            }
            
            // åˆ›å»ºåˆå¹¶æ•ˆæœ
            function createMergeEffect(x, y, radius, score) {
                // é—ªçƒæ•ˆæœ
                const flashEffect = {
                    x, y, radius: radius * 1.5, alpha: 1, 
                    update: function(deltaTime) {
                        this.alpha -= deltaTime / 300;
                        return this.alpha > 0;
                    },
                    draw: function() {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                        ctx.fill();
                        ctx.restore();
                    }
                };
                
                // æ·»åŠ åˆ°ç‰¹æ•ˆåˆ—è¡¨
                effects.push(flashEffect);
                
                // æ’­æ”¾åˆ†æ•°å¢åŠ åŠ¨ç”»
                const scorePopup = {
                    x, y: y - radius, text: `+${score}`, 
                    alpha: 1, ySpeed: -2, 
                    update: function(deltaTime) {
                        this.y += this.ySpeed;
                        this.alpha -= deltaTime / 1000;
                        return this.alpha > 0;
                    },
                    draw: function() {
                        ctx.save();
                        ctx.font = "bold 16px 'Comic Sans MS', sans-serif";
                        ctx.fillStyle = `rgba(255, 210, 102, ${this.alpha})`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 2;
                        ctx.fillText(this.text, this.x, this.y);
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }
                };
                
                effects.push(scorePopup);
            }
            
            // åˆ›å»ºç‚¹å‡»æ•ˆæœ
            function createTapEffect(x, y) {
                const tapIndicator = document.createElement('div');
                tapIndicator.className = 'tap-indicator';
                document.getElementById('gameContainer').appendChild(tapIndicator);
                tapIndicator.style.left = `${x}px`;
                tapIndicator.style.top = `${y}px`;
                
                // ç§»é™¤æ•ˆæœå…ƒç´ 
                setTimeout(() => {
                    tapIndicator.remove();
                }, 600);
            }
            
            // ç‰¹æ•ˆåˆ—è¡¨
            const effects = [];
            
            // å¢åŠ åˆ†æ•°
            function addScore(points) {
                state.score += points;
                document.getElementById('score').textContent = state.score;
                
                // æ›´æ–°æœ€é«˜åˆ†
                if (state.score > state.highScore) {
                    state.highScore = state.score;
                    document.getElementById('highScore').textContent = state.highScore;
                    localStorage.setItem('watermelonHighScore', state.highScore);
                }
                
                // åˆ†æ•°å˜åŒ–åŠ¨ç”»
                const scoreElement = document.getElementById('score');
                scoreElement.classList.add('pulse-animation');
                setTimeout(() => {
                    scoreElement.classList.remove('pulse-animation');
                }, 300);
            }
            
            // æ”¾ç½®æ°´æœ
            function placeFruit(x, y) {
                if (state.gameOver || !state.activeFruit || state.activeFruit.isFalling) return;
                
                // åˆ›å»ºç‚¹å‡»æ•ˆæœ
                createTapEffect(x, y);
                
                // è®¾ç½®æ°´æœä½ç½®
                state.activeFruit.x = Math.max(
                    state.activeFruit.radius, 
                    Math.min(canvas.width - state.activeFruit.radius, x)
                );
                
                // å¼€å§‹ä¸‹è½
                state.activeFruit.isFalling = true;
                
                // ç»™äºˆéšæœºåˆé€Ÿåº¦å’Œæ—‹è½¬ (é™ä½åˆå§‹æ—‹è½¬é€Ÿåº¦)
                const speed = config.minFruitSpeed + Math.random() * (config.maxFruitSpeed - config.minFruitSpeed);
                state.activeFruit.vy = speed;
                // é™ä½åˆå§‹æ—‹è½¬é€Ÿåº¦
                state.activeFruit.angularVelocity = (Math.random() - 0.5) * config.maxRotationSpeed * 0.5;
                
                // å°†å½“å‰æ°´æœæ·»åŠ åˆ°æ°´æœåˆ—è¡¨
                state.fruits.push(state.activeFruit);
                
                // å‡†å¤‡ä¸‹ä¸€ä¸ªæ°´æœ
                state.activeFruit = state.nextFruit;
                state.nextFruit = createFruit();
                updateNextFruitPreview();
            }
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            function checkGameOver() {
                // æ£€æŸ¥æ°´æœæ•°é‡æ˜¯å¦è¶…è¿‡ä¸Šé™
                if (state.fruits.length >= config.maxFruits) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ°´æœè¶…è¿‡é¡¶éƒ¨è¾¹ç•Œ
                for (const fruit of state.fruits) {
                    if (fruit.y - fruit.radius < 0) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // æ¸¸æˆç»“æŸ
            function endGame() {
                state.gameOver = true;
                cancelAnimationFrame(state.animationId);
                
                // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
                const gameOverScreen = document.getElementById('gameOver');
                document.getElementById('finalScore').textContent = state.score;
                gameOverScreen.classList.remove('hidden');
                
                // ä¿å­˜æœ€é«˜åˆ†
                if (state.score > state.highScore) {
                    state.highScore = state.score;
                    localStorage.setItem('watermelonHighScore', state.highScore);
                }
            }
            
            // é‡ç½®æ¸¸æˆ
            function resetGame() {
                state = {
                    fruits: [],
                    activeFruit: createFruit(),
                    nextFruit: createFruit(),
                    score: 0,
                    highScore: localStorage.getItem('watermelonHighScore') || 0,
                    gameOver: false,
                    lastSpawnTime: performance.now(),
                    animationId: null,
                    lastTime: 0,
                    isDragging: false
                };
                
                document.getElementById('score').textContent = state.score;
                document.getElementById('highScore').textContent = state.highScore;
                document.getElementById('gameOver').classList.add('hidden');
                updateNextFruitPreview();
                
                // å¼€å§‹æ¸¸æˆå¾ªç¯
                gameLoop(performance.now());
            }
            
            // æ¸¸æˆå¾ªç¯
            function gameLoop(currentTime) {
                if (state.gameOver) return;
                
                // è®¡ç®—æ—¶é—´å·®
                const deltaTime = currentTime - (state.lastTime || currentTime);
                state.lastTime = currentTime;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // æ›´æ–°å’Œç»˜åˆ¶ç‰¹æ•ˆ
                for (let i = effects.length - 1; i >= 0; i--) {
                    if (!effects[i].update(deltaTime)) {
                        effects.splice(i, 1);
                    } else {
                        effects[i].draw();
                    }
                }
                
                // å¤„ç†å½“å‰å¯æ”¾ç½®æ°´æœçš„åŠ¨ç”»
                if (state.activeFruit && !state.activeFruit.isFalling) {
                    if (state.activeFruit.isNew) {
                        state.activeFruit.scale += deltaTime / 100;
                        if (state.activeFruit.scale >= 1) {
                            state.activeFruit.scale = 1;
                            state.activeFruit.isNew = false;
                        }
                    }
                    
                    // ç»˜åˆ¶å½“å‰å¯æ”¾ç½®çš„æ°´æœ
                    drawFruit(state.activeFruit);
                }
                
                // æ›´æ–°æ‰€æœ‰æ°´æœçš„ç‰©ç†çŠ¶æ€
                for (const fruit of state.fruits) {
                    // æ–°æ°´æœçš„ç¼©æ”¾åŠ¨ç”»
                    if (fruit.isNew) {
                        fruit.scale += deltaTime / 100;
                        if (fruit.scale >= 1) {
                            fruit.scale = 1;
                            fruit.isNew = false;
                        }
                    }
                    
                    // æ›´æ–°ç‰©ç†çŠ¶æ€
                    updatePhysics(fruit, deltaTime);
                    
                    // ç»˜åˆ¶æ°´æœ
                    drawFruit(fruit);
                }
                
                // æ£€æµ‹å¹¶å¤„ç†æ°´æœä¹‹é—´çš„ç¢°æ’
                for (let i = 0; i < state.fruits.length; i++) {
                    for (let j = i + 1; j < state.fruits.length; j++) {
                        if (checkCollision(state.fruits[i], state.fruits[j])) {
                            // å…ˆå°è¯•åˆå¹¶
                            const merged = handleMerge(state.fruits[i], state.fruits[j]);
                            // å¦‚æœæ²¡æœ‰åˆå¹¶ï¼Œåˆ™å¤„ç†ç¢°æ’ç‰©ç†æ•ˆæœ
                            if (!merged) {
                                resolveCollision(state.fruits[i], state.fruits[j]);
                            }
                        }
                    }
                }
                
                // ç§»é™¤å·²åˆå¹¶çš„æ°´æœ
                state.fruits = state.fruits.filter(fruit => !fruit.merged);
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (checkGameOver()) {
                    endGame();
                    return;
                }
                
                // ç»§ç»­æ¸¸æˆå¾ªç¯
                state.animationId = requestAnimationFrame(gameLoop);
            }
            
            // äº‹ä»¶ç›‘å¬ - ç‚¹å‡»æ”¾ç½®æ°´æœ
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                placeFruit(x, y);
            });
            
            // äº‹ä»¶ç›‘å¬ - è§¦æ‘¸å±
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // é˜²æ­¢è§¦æ‘¸äº‹ä»¶çš„é»˜è®¤è¡Œä¸º
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // è®°å½•è§¦æ‘¸å¼€å§‹ä½ç½®ï¼Œç”¨äºæ‹–åŠ¨
                if (state.activeFruit && !state.activeFruit.isFalling) {
                    state.isDragging = true;
                    // ç›´æ¥ç§»åŠ¨æ°´æœåˆ°è§¦æ‘¸ä½ç½®
                    state.activeFruit.x = Math.max(
                        state.activeFruit.radius, 
                        Math.min(canvas.width - state.activeFruit.radius, x)
                    );
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (state.isDragging && state.activeFruit && !state.activeFruit.isFalling) {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    
                    // æ‹–åŠ¨æ—¶æ›´æ–°æ°´æœä½ç½®
                    state.activeFruit.x = Math.max(
                        state.activeFruit.radius, 
                        Math.min(canvas.width - state.activeFruit.radius, x)
                    );
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                if (state.isDragging) {
                    state.isDragging = false;
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.changedTouches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    placeFruit(x, y);
                }
            }, { passive: false });
            
            // é‡æ–°å¼€å§‹æŒ‰é’®
            document.getElementById('restartBtn').addEventListener('click', resetGame);
            
            // å¼€å§‹æ¸¸æˆ
            gameLoop(performance.now());
        });
    </script>
    <script>
  setTimeout(()=>{
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c064ad264d46ace151769a317e6ebeef";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
  },5000)
</script>
</body>
</html>
    